
## d = 1
# Type I setting: c0[j,:] \neq 0 for all j \in [k0].
if model == 1: # cf. Simulation of [Ho and Nguyen (2016), Annals of Statistics].
    d = 1
    l = 1
    K0= 3
    
    def get_params(n):
        # # Joint-GLLiM.
        # theta0 = np.array([[-.1,.3],[.1,-.4],[.5,.2]])
        # sigma0 = np.array([np.array([[4.2824, 1.7324],[1.7324, .81759]]), \
        #                    np.array([[1.75,-1.25],[-1.25,1.75]]), \
        #                        np.array([[1,0],[0,4]]) ]) / 100.0 
    
        # GLLiM.
        pi0     = np.array([.3, .4, .3])
        c0      = np.array([[-.1],[.1],[.5]])
        Gamma0  = np.array([np.array([[.042824]]), \
                           np.array([[.0175]]), \
                               np.array([[.01]]) ]) 
        A0      = np.array([np.array([[.017324*(.042824**(-1))]]), \
                           np.array([[-.0125*(.0175**(-1))]]), \
                               np.array([[0*(.01**(-1))]]) ])
        b0      = np.array([[.3-.017324*(.042824**(-1))*(-.1)],\
                       [-.4+.0125*(.0175**(-1))*.1],\
                       [.2 +0*(.0175**(-1))*.5]])
        nu0     = np.array([np.array([[.0081759 - .017324*(.042824**(-1))*(-.1)*.017324]]), \
                           np.array([[.0175 + .0125*(.0175**(-1))*.0125]]), \
                               np.array([[.0175 + 0*(.01**(-1))*0]])]) 
        return (pi0, c0, Gamma0, A0, b0, nu0)

## Type II setting: c0[j,:] = 0 for all j \in [\tilde{k}_0] 
## and c0[j,:] \neq 0 for all [\tilde{k}_0 + 1] \le j \le \in [k0].
elif model == 2:    
    d = 1
    l = 1
    K0= 3
  
    def get_params(n):
        # # Joint-GLLiM.
        # theta0 = np.array([[0,.3],[.1,-.4],[.5,.2]])
        # sigma0 = np.array([np.array([[4.2824, 1.7324],[1.7324, .81759]]), \
        #                    np.array([[1.75,-1.25],[-1.25,1.75]]), \
        #                        np.array([[1,0],[0,4]]) ]) / 100.0 
    
        # GLLiM.
        pi0     = np.array([.3, .4, .3])
        c0      = np.array([[0],[.1],[.5]])
        Gamma0  = np.array([np.array([[.042824]]), \
                           np.array([[.0175]]), \
                               np.array([[.01]]) ]) 
        A0      = np.array([np.array([[.017324*(.042824**(-1))]]), \
                           np.array([[-.0125*(.0175**(-1))]]), \
                               np.array([[0*(.01**(-1))]]) ])
        b0      = np.array([[.3 - .017324*(.042824**(-1))*0],\
                       [-.4 + .0125*(.0175**(-1))*.1],\
                       [.2 + 0*(.0175**(-1))*.5]])
        nu0     = np.array([np.array([[.0081759 - .017324*(.042824**(-1))*.017324]]), \
                           np.array([[.0175 + .0125*(.0175**(-1))*.0125]]), \
                               np.array([[.0175 + 0*(.01**(-1))*0]])]) 
        return (pi0, c0, Gamma0, A0, b0, nu0)

# d = 2
# Type I setting: c0[j,:] \neq 0 for all j \in [k0].    
elif model == 3: # cf. Simulation of [Ho and Nguyen (2016), Annals of Statistics].
    ##
    # A0 = 
    # array([[[ 0.40453951,  0.40453951]],

    #        [[-0.71428571, -0.71428571]],

    #        [[ 0.        ,  0.        ]]])
    
    # b0 = 
    # array([[ 0.34045395],
    #        [-0.32857143],
    #        [ 0.2       ]])
    # nu0 = 
    # array([[[0.00887672]],

    #        [[0.02642857]],

    #        [[0.0175    ]]])
    ##
    d = 2
    l = 1
    K0= 3
    
    def get_params(n):
        # Joint-GLLiM.
        # theta0 = np.array([[-.1,.3],[.1,-.4],[.5,.2]])
        # sigma0 = np.array([np.array([[4.2824, 1.7324],[1.7324, .81759]]), \
        #                    np.array([[1.75,-1.25],[-1.25,1.75]]), \
        #                        np.array([[1,0],[0,4]]) ]) / 100.0 
    
        # GLLiM.
        pi0     = np.array([.3, .4, .3])
        
        c0      = np.array([[-.1, -.1],[.1, .1],[.5, .5]])
        
        Gamma0  = np.array([np.array([[.042824, 0], [0, .042824]]), \
                           np.array([[.0175, 0], [0, .0175]]), \
                               np.array([[.01, 0], [0, .01]]) ])
            
        A0      = np.array([np.array([[.017324*(.042824**(-1)), .017324*(.042824**(-1))]]), \
                           np.array([[-.0125*(.0175**(-1)), -.0125*(.0175**(-1))]]), \
                               np.array([[0*(.01**(-1)), 0*(.01**(-1))]]) ])
            
        b0      = np.array([[.3-.017324*(.042824**(-1))*(-.1)],\
                       [-.4+.0125*(.0175**(-1))*.1],\
                       [.2 +0*(.0175**(-1))*.5]])
            
        nu0     = np.array([np.array([[.0081759 - .017324*(.042824**(-1))*(-.1)*.017324]]), \
                           np.array([[.0175 + .0125*(.0175**(-1))*.0125]]), \
                               np.array([[.0175 + 0*(.01**(-1))*0]])])
            
        # return (theta0, sigma0, pi0, c0, Gamma0, A0, b0, nu0)
        return (pi0, c0, Gamma0, A0, b0, nu0)    

## Type II setting: c0[j,:] = 0 for all j \in [\tilde{k}_0] 
elif model == 4:    
    d = 2
    l = 1
    K0= 3
  
    def get_params(n):
        # # Joint-GLLiM.
        # theta0 = np.array([[0,.3],[.1,-.4],[.5,.2]])
        # sigma0 = np.array([np.array([[4.2824, 1.7324],[1.7324, .81759]]), \
        #                    np.array([[1.75,-1.25],[-1.25,1.75]]), \
        #                        np.array([[1,0],[0,4]]) ]) / 100.0 
    
        # GLLiM.
        pi0     = np.array([.3, .4, .3])
        
        c0      = np.array([[0, 0], [.1, .1], [.5, .5]])
        
        Gamma0  = np.array([np.array([[.042824, 0], [0, .042824]]), \
                           np.array([[.0175, 0], [0, .0175]]), \
                               np.array([[.01, 0], [0, .01]]) ])
            
        A0      = np.array([np.array([[.017324*(.042824**(-1)), .017324*(.042824**(-1))]]), \
                           np.array([[-.0125*(.0175**(-1)), -.0125*(.0175**(-1))]]), \
                               np.array([[0*(.01**(-1)), 0*(.01**(-1))]]) ])
            
        b0      = np.array([[.3 - .017324*(.042824**(-1))*0],\
                       [-.4 + .0125*(.0175**(-1))*.1],\
                       [.2 + 0*(.0175**(-1))*.5]])
            
        nu0     = np.array([np.array([[.0081759 - .017324*(.042824**(-1))*.017324]]), \
                           np.array([[.0175 + .0125*(.0175**(-1))*.0125]]), \
                               np.array([[.0175 + 0*(.01**(-1))*0]])]) 
        return (pi0, c0, Gamma0, A0, b0, nu0)    
    
else:
    sys.exit("Model unrecognized.")